<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Nginx加权轮询算法]]></title>
      <url>%2F2017%2F04%2F06%2FNginx%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[记录一下nginx加权分配算法。 nginx可以指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如：12345upstream backend &#123; server a weight=6; server b weight=3; server c weight=1;&#125; 按照配置，每有10次请求，其中6个会转发到a服务器，3个转发到b服务器，1个转发到c服务器。 每个服务器都有三个权重变量，先解释下它们的含义。 (1) weight 配置文件中指定的该服务器的权重，这个值是固定不变的。 (2) effective_weight 服务器的有效权重，初始值为weight。 在释放服务器时，如果发现和某服务器的通信过程中发生了错误，就减小它的effective_weight。此后有新的请求过来时，在选取该服务器的过程中，再逐步增加effective_weight，最终又恢复到weight。之所以增加这个字段，是为了当服务器发生错误时，降低其权重。 (3) current_weight 服务器目前的权重，初始为0，之后会动态调整。 那么如何动态调整呢？ nginx每次选取服务器时： 先遍历集群中所有服务器，将每个服务器的current_weight增加它的effective_weight， 再累加所有服务器的effective_weight，保存为total。 判断当前服务器的current_weight是否最大，是则选中该服务器，然后把它的current_weight减去total。不是则不会被选中，current_weight也就不用减了。 弄清了三个weight字段的含义后，加权轮询算法可描述为： 对于每个请求，遍历集群中的所有可用服务器，对于每个服务器执行： current_weight += effecitve_weight。 累加所有effective_weight，保存为total。 选出current_weight最大的服务器，作为本次选定的服务器。 对于本次选定的服务器，执行：current_weight -= total。 下面以表格形式记录其过程： 请求次数 开始current_weight 增加effective_weight 累加total 选中服务器 选中后current_weight 1 [0, 0, 0] [6, 3, 1] 10 a [-4, 3, 1] 2 [-4, 3, 1] [2, 6, 2] 10 b [2, -4, 2] 3 [2, -4, 2] [8, -1, 3] 10 a [-2, -1, 3] 4 [-2, -1, 3] [4, 2, 4] 10 a [-6, 2, 4] 5 [-6, 2, 4] [0, 5, 5] 10 b [0, -5, 5] 6 [0, -5, 5] [6, -2, 6] 10 a [-4, -2, 6] 7 [-4, -2, 6] [2, 1, 7] 10 c [2, 1, -3] 8 [2, 1, -3] [8, 4, -2] 10 a [-2, 4, -2] 9 [-2, 4, -2] [4, 7, -1] 10 b [4, -3, -1] 10 [4, -3, -1] [10, 0, 0] 10 a [0, 0, 0] 可以看到，选中服务器依次为[a, b, a, a, b, a, c, a, b, a]。 a,b,c分别被选中了6,3,1次，正好是符合其权重值的；服务器a虽然权重大，但没有被连续选取，不会对a服务器连续请求；经过10次请求后，a,b,c的当前权重current_weight又全部归0，如此便可循环往复。 ps: 这里我们发现total永远都是10，因为这里假定服务器都没有发生故障或返回错误，其effective_weight不变。实际中如果服务器发生了错误，nginx当然也会进行降权处理，total也会变啦。这里我们学习一下正常算法，出错的情况就先不展开了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-next主题添加打赏功能]]></title>
      <url>%2F2017%2F04%2F05%2Fhexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[next主题集成了打赏功能，使用起来比较简单。 首先获取微信收款二维码和支付宝收款二维码： 微信：点击右上角的加号”+”，点击”收付款”，点击”我要收款”，就可以看到自己的收款二维码了。还可以点击”设置金额”，之后保存图片(名字可修改为wechatpay.png)。 支付宝： 同理，点击右上角的加号”+”，点击”收钱”,出现二维码，也可以设置金额，之后保存图片(名字可修改为ailpay.jpg)。 我们可以在source目录下建立一个images文件夹，将上面保存的图片放入。 找到主题next下的配置文件_config.yml，添加信息如下：1234# rewardreward_comment: 如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg hexo发布，文章下面就会出现一个赏字，点开效果如下： 以上就成功添加了打赏功能(虽然基本不会有人打赏。。。)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多台电脑hexo部署到github的坑]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[之前在家里搭建了博客，成功部署到github上，并将hexo目录也上传至github/hexo仓库保存。后来到公司想把它们down下来，方便两边修改同步。 第一个坑是hexo发布博客到github同样进行了一系列的node安装，hexo安装等，并且在hexo博客目录下down下了guthub/hexo的资源，本地启动，没问题。但是当我发布想发布到yourname.github.io上时，问题来了，它居然把我的整个hexo博客目录扔到了yourname.github.io上，不是说好的只发布.deploy_git下的内容呢！！ 于是我就茫然了啊，我去查看hexo下的_config.yml文件，1234deploy: type: git repo: git@github.com:tenny-peng/tenny-peng.github.io.git branch: master 没错啊，是这个地址啊。 后来一想也不对，就算这里错了也不对，不是目标地址错了，而是发布的内容错了。 网上查到了这篇博客: hexo部署到github遇到的坑，最后说删除hexo目录下的.git文件，然后我就试了试，重新发布，然后又报错了。。这里想截图可是命令行找不到了，大概就是说没有指定repository，然后我点开.deploy_git文件夹，突然想到在家里.deploy_git文件夹下面是有.git的，而且还是我自己指定的。 哈哈，瞬间好像知道了，打开git bash，切换到hexo/.deploy_git，执行1git init 再绑定远程仓库1git remote add origin git@github.com:tenny-peng/tenny-peng.github.io.git 回到cmd命令行1hexo d 搞定了，成功提交了正确的博客内容。 第二个坑是hexo目录与github/hexo同步然后再把我的hexo目录和github/hexo同步，刚才把hexo目录下的.git删了。好吧，重新建回来。git bash切换到hexo根目录123git initgit remote add origin git@github.com:tenny-peng/hexo.git 执行pull指令123456789101112$ git pull origin masterFrom github.com:tenny-peng/hexo * branch master -&gt; FETCH_HEADerror: The following untracked working tree files would be overwritten by merge: .npmignore _config.yml db.json node_modules/.bin/JSONStream node_modules/.bin/JSONStream.cmd node_modules/.bin/acorn node_modules/.bin/acorn.cmd ... 这里说一下，第一个坑中hexo目录下的内容是我直接从github/hexo上down下来复制过来的，然后本地又进行过hexo生成和发布操作，错误具体原因不太清除(知道的童鞋欢迎指正)，网上查到解决办法是先清理1234567891011$ git clean -f -dSkipping repository .deploy_git/Removing .npmignoreRemoving _config.ymlRemoving db.jsonRemoving node_modules/Removing package.jsonRemoving public/Removing scaffolds/Removing source/Removing themes/ 清理后hexo目录下只剩.deploy_git和.git目录，再拉取就可以了1234$ git pull origin masterFrom github.com:tenny-peng/hexo * branch master -&gt; FETCH_HEADChecking out files: 100% (7651/7651), done. 所以下次可以先同步好hexo文件夹，这样第二个坑应该就不会出现了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修复TortoiseGit图标不显示]]></title>
      <url>%2F2017%2F04%2F04%2F%E4%BF%AE%E5%A4%8DTortoiseGit%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[win + r 打开运行，输入regedit.exe打开注册表 找到HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer 修改符串值 “Max Cached Icons” (如没有则新建)值为 “10000”(切换到十进制)。 Ctrl + Alt + Del 打开任务管理器,找到explorer.explorer 右键选中explorer.exe，在弹出选项中选择”结束进程”,这个时候会发现电脑底部状态栏没有了，不用担心。 任务管理器上方的”文件”选项，点击”新建任务(运行)”，输入explorer.exe，确定即可。 由于Windows Explorer Shell 支持的 Overlay Icon 最多 15 个，Windows 自身使用了 4 个，只剩 11 个可扩展使用。我们在这里调节了它的最大图标数。explorer.exe是Windows程序管理器或者文件资源管理器，它用于管理Windows图形壳，包括桌面和文件管理，重启explorer.exe就可以看到我们的修改了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown设置字体颜色]]></title>
      <url>%2F2017%2F04%2F03%2FMarkDown%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%2F</url>
      <content type="text"><![CDATA[记录一下如何设置字体颜色和大小12&lt;font color=red size=5&gt;gray&lt;/font&gt;&lt;font color=&quot;#4590a3&quot; size=&quot;6px&quot;&gt;文字&lt;/font&gt; 效果如下： red文字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo引用本地图片]]></title>
      <url>%2F2017%2F04%2F03%2FMarkDown%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[markdown文章里引用图片有两种方式。一种是直接引用互联网上的图片，使用绝对路径 http://xxx.com/xxx.jpg 一种是使用本地图片。 因为最后要发布到网上，所以引用本地图片路径必须是相对路径xxx/xxx.png 这里讲如何引用本地图片。首先在站点_config.yml 中找到”post_asset_folder”属性，将其设置为”true”。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder。当设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 启动cmd,切换到hexo的目录下执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 等待一段时即可。 安装完成后用hexo新建文章的时候_posts目录下面会多出一个和文章同名的文件夹。图片就可以放在该文件夹下面使用。 把你要引用的图片放在同名目录下,如下引用即可。 1![xxx](testpic/xxxxxx.png) 个人感觉也可以不装这个插件，自己手动建立同名文件夹也可以的。但是装了还是方便，毕竟hexo新建文章能初始化一些信息。 再说下本人踩过的坑。在source目录下建立images文件夹存放图片，然后通过../images/xxx.png引用，感觉是没什么问题的，实际在本地也没问题。但是上传到github就不对了。github上去找寻的路径类似https://tenny-peng.github.io/2017/04/04/images/xxx.png。很明显这是找不到的，因为发布后2017/04/04下只有文章，没有其他文件或文件夹。也试过在_posts下建立images,通过images/xxx.png引用，结果是一样的。 然后建立了同名文件夹，到github上查看发布后的文件才发现，对于每个md文件，生成一个同名的文件夹，里面有一个index.html文件是md文件转化的内容，我们当初自建的同名文件夹下的图片也在该文件夹下，例如，在github上，对于testpic.md,生成一个testpic文件夹，里面有一个index.html,其内容就是我们得testpic.md里编写的内容，而我们当时正好建立了同名的文件夹来存放图片，此时，这些图片也到了github下的同名文件夹。如此一来，引用就没有问题了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git简单教程]]></title>
      <url>%2F2017%2F04%2F03%2FGit%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[简介Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目, 可以有效、高速的处理从很小到非常大的项目版本管理。 安装由于本人是Windows平台，所以这里安装的是Windows平台下的工具。 点击https://git-scm.com/download/win下载 如果网速太慢可以百度搜索“git下载”。 下载完成之后一路next就可以了， 安装完成后，开始菜单找到”git”-&gt;”Git Bash”， 在命令行输入1git --version 看到类似如下结果，说明我们安装成功了。 安装完成后，还需要一点设置，在打开的git bash命令行中输入12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意把上面改成自己的名字和邮箱地址 git config命令的–global参数，表示你这台机器上所有的Git仓库都会使用这个配置， 当然也可以对某个仓库指定不同的用户名和Email地址。 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 使用github我们希望项目不只是在本地，只有有网，哪里都可以获取自己的项目，GitHub 正是这样一个面向开源及私有软件项目的托管平台。我们可以把自己的项目放在这个平台上，可以和其他人维护项目。 后面会讲git的基本操作，你也可以直接到后面查看。作为一般流程，这里让我们先注册一个github账号 进入github网站,点击sign up 填写信息后点击”create an account” 按钮 之后进入到我们的首页 这样我们已经成功拥有了一个github账号，让我们正式开始吧~ 简单说下仓库的概念，仓库的英文名是repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 点击上面的+号，新建一个仓库 输入我们的仓库名称后，点击下面”create repository”按钮即可创建一个仓库 我们可以看到这个仓库是空的，什么都没有。 接下来，我们回到本地git上。 克隆仓库由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以还需要一点设置： 回到git bash命令窗口，创建SSH key:1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登录你的github，进入setting，点击”SSH and GPG keys”,点击右上角”New SSH Key”,tite随便填，Key文本框里粘贴id_rsa.pub文件的内容，最后点击”Add SSh Key”即可。 可以看到我这里已经有两个了，一个家里一个公司，这样就可以两边同步信息了。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 接下来输入1cd e: 切换目录，执行1git clone git@github.com:tenny-peng/test.git 稍等一会，就可将github上的项目克隆到本地 这里我选的e盘根目录，你可以自己修改，注意：选择的目录下不可以有仓库同名目录如我的e盘下不能有test这个目录，不然在克隆时会报错。 这里有一个警告，说我们的仓库是空的，不用管它，我们马上会添加文件。 添加文件使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把notepad++的默认编码设置为UTF-8without BOM即可。 在仓库test文件目录下，我们先编写一个readme.txt文件，内容如下：12Git is a version control system.Git is free software. 这里我们可以看到test目录下有一个隐藏的.git目录(看不到可自行百度“windows查看隐藏文件方法”)，这个就说明此目录是由git管理的仓库了，如果删除了这个隐藏的目录，那个git也就不认识这个目录了，也不能对此目录下的文件进行管理了。 回到命令行，输入1git add readme.txt 什么反馈信息也没有？那就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 使用1git status 可查看当前仓库状态 我们发现提示有新文件，但是这样还不够。 我们继续输入1git commit -m &quot;add readme.txt&quot; 这样才把文件提交到仓库，再次输入”git status”查看状态 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 推送这里我就在仓库里新增了一个文件，当然还会有修改，删除操作。其实这样就可以管理自己的项目了。但是，我们似乎忘记了github。对，我们需要的是随时随处可获取，所以我们需要把本地仓库的内容同步到github这个托管平台。 当你从远程仓库克隆时，实际上Git自动把本地的master分支(分支后面再讲，简单理解为仓库的多个版本，默认一个主分支)和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，输入1git remote 或1git remote -v 获取更详细信息 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 接下来我们把本地改动(这里新增了一个文件，对于git，新增，修改，删除，都属于改动)推送到远程仓库。1git push origin master 刷新浏览器中我们的github主页，可以看到，readme.txt文件已经同步到远程仓库了。 以上我们就使用git创建了自己的仓库，并将其同步到远程服务器上，以便我们在其它地方，或其他人获取。 参考： 廖雪峰的git教程 git互动百科 github互动百科]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown基础语法]]></title>
      <url>%2F2017%2F04%2F03%2FMarkDown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[标准mrakdown语法加粗和斜体字体加粗以两个*或两个_开头结尾1__重要的事情说三遍！！！__ **重要的事情说三遍！！！** 效果如下： 重要的事情说三遍！！！ 字体倾斜以一个*或_开头结尾1_一段斜体文字_ *一段斜体文字* 效果如下： 一段斜体文字 链接和邮件链接：12bla bla bla [example](http://url.com/ &quot;Title&quot;)这是我们常用的网站: [百度一下](www.baidu.com &quot;百度一下&quot;) 效果如下： 这是我们常用的网站: baidu 也可以定义一个id来对应链接地址12345bla bla bla [example][id]. Then, anywhere else in the doc, define the link:[id]: http://example.com/ &quot;Title&quot;这是我们常用的网站: [baidu][baiduId][baiduId]: www.baidu.com &quot;百度一下&quot; 效果如下： 这是我的博客，欢迎访问。 邮件：12An email &lt;example@example.com&gt; link.这是我的邮箱&lt;mpengtaoqi@163.com&gt;。 效果如下： 这是我的邮箱&#x6d;&#x70;&#x65;&#110;&#x67;&#x74;&#x61;&#x6f;&#113;&#x69;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;。 图片行内引用 (标题可选):12![alt text](/path/img.jpg &quot;Title&quot;)这里出现一个引用的图片![图片替代文字](https://tenny-peng.github.io/images/avatar.jpg &quot;偷得浮生半日闲&quot;) 效果如下： 这里出现一个引用的图片 使用id引用图片链接：12345![alt text][id][id]: /url/to/img.jpg &quot;Title&quot;使用id引用图片链接![图片替代文字][img_id][img_id](https://tenny-peng.github.io/images/avatar.jpg &quot;偷得浮生半日闲&quot;) 效果如下： 使用id引用图片链接 标题底线形式:12345标题 1========标题 2-------- 效果如下： 标题 1标题 2#模式 (末尾的#可选):12345# 标题 1 ### 标题 2 ######## 标题 6 效果如下： 标题 1标题 2标题 6列表有序的, 不带段落:1231. Git2. Hexo3. MarkDown 效果如下： Git Hexo MarkDown 无序的, 带段落:12345* 一个条目. 巴拉巴拉拉，这里是段落文字.* 其他条目 效果如下： 一个条目. 巴拉巴拉巴拉，这里是段落文字. 其他条目 你可以嵌套使用它们：12345678* Work * java* Blog 1. github 2. atom * markdown 3. hexo* learn 效果如下： Work java Blog github atom markdown hexo learn 区块引用123456789&gt; 类似邮件的引用方式&gt; 在断好的行前加上`&gt;`&gt; &gt; 也可以嵌套使用&gt; #### 引用标题&gt;&gt; * 也可以是一个列表&gt; * 等等 效果如下： 类似邮件的引用方式在断好的行前加上&gt; 也可以嵌套使用 引用标题 也可以是一个列表 等等 内联代码12345`&lt;some code&gt;` 使用引号和反引号标记行内代码片段。如果要在代码区段内插入反引号，可以用多个反引号来开启和结束代码区段。例如 `` `this` ``. 效果如下： &lt;some code&gt; 使用引号和反引号标记行内代码片段。 如果要在代码区段内插入反引号，可以用多个反引号来开启和结束代码区段。 例如 `this` . 代码块在句段的行首插入1个tab 或 4个空格，则表示代码块。123这是一段普通的文字。 这一段代码块。 分隔线用三个以上的星号或减号或底线来建立一个水平分隔线。 行内不能有其他东西，但你可以在星号或是减号中间插入空格。12345---* * *- - - - 效果如下： 换行在一行的结尾处加上2个或2个以上的空格12Roses are red, Violets are blue. 效果如下： Roses are red,Violets are blue. 表格123456| 字段 | 左对齐 | 居中 | 右对齐 | //表头|------|:------|:----:|------:| //对齐方式(默认左对齐)| 1 | left1 | center1 | right1 | //内容| 2 | left2 | center2 | right2 || 3 | left3 | center3 | right3 || 4 | left4 | center4 | right4 | 效果如下： 默认字段 左对齐字段 居中字段 右对齐字段 1 left1 center1 right1 2 left2 center2 right2 3 left3 center3 right3 4 left4 center4 right4]]></content>
    </entry>

    
  
  
</search>
